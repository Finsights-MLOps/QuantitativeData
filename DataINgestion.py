import pandas as pd
import numpy as np
import time
from sec_edgar_api import EdgarClient
from datetime import date
import json
import requests
import boto3

session = boto3.session.Session(profile_name='Finsights')
s3_client = session.client('s3')


# -------------------- XBRL_TAGS --------------------
XBRL_TAGS = {
    # -------------------- INCOME STATEMENT --------------------
    "income_stmt_Revenue": {
        "tag": "Revenues",
        "description": "Total revenue generated by the company from its main business operations for the fiscal year. It represents the top line of the income statement and indicates the scale of operations. Unit: USD.",
        "theme": "Growth",
        "unit": "USD"
    },
    "income_stmt_Cost of Revenue": {
        "tag": "CostOfRevenue",
        "description": "Total cost incurred to produce goods or services sold during the fiscal year. Used to calculate Gross Profit. Lower cost relative to revenue indicates better efficiency. Unit: USD.",
        "theme": "Profitability",
        "unit": "USD"
    },
    "income_stmt_Gross Profit": {
        "tag": "GrossProfit",
        "description": "Gross Profit = Revenue − Cost of Revenue. Indicates how much profit is generated before operating expenses. Higher margin means better efficiency in producing goods/services. Unit: USD.",
        "theme": "Profitability",
        "unit": "USD"
    },
    "income_stmt_Operating Expenses": {
        "tag": "OperatingExpenses",
        "description": "Expenses related to core business operations excluding cost of revenue (e.g., SG&A, R&D). Helps calculate Operating Income. Unit: USD.",
        "theme": "Profitability",
        "unit": "USD"
    },
    "income_stmt_Interest Expense": {
        "tag": "InterestExpense",
        "description": "Cost of borrowed funds during the fiscal year. Impacts net income and financial leverage. Unit: USD.",
        "theme": "Leverage",
        "unit": "USD"
    },
    "income_stmt_Provision for Income Tax": {
        "tag": "IncomeTaxExpenseBenefit",
        "description": "Income tax expense recognized during the fiscal year. Used in calculating Net Income. Unit: USD.",
        "theme": "Profitability",
        "unit": "USD"
    },
    "income_stmt_Net Income": {
        "tag": "NetIncomeLoss",
        "description": "Net Income = Total Revenue − Total Expenses − Taxes. Shows overall profitability for the fiscal year. Unit: USD. Typical benchmark: Positive net income indicates profit; negative indicates loss.",
        "theme": "Profitability",
        "unit": "USD"
    },

    # -------------------- BALANCE SHEET --------------------
    "balance_sheet_Current Assets": {
        "tag": "AssetsCurrent",
        "description": "Assets expected to be converted into cash or used up within one year (e.g., cash, inventory, receivables). Used in liquidity ratios like Current Ratio. Unit: USD. Ideal Current Ratio: 1.2–2.0.",
        "theme": "Liquidity",
        "unit": "USD"
    },
    "balance_sheet_Total Assets": {
        "tag": "Assets",
        "description": "Total resources owned by the company with economic value. Used in calculating ROA and debt ratios. Unit: USD.",
        "theme": "Growth",
        "unit": "USD"
    },
    "balance_sheet_Current Liabilities": {
        "tag": "LiabilitiesCurrent",
        "description": "Obligations due within one year (e.g., accounts payable, short-term debt). Used in liquidity ratios. Unit: USD.",
        "theme": "Liquidity",
        "unit": "USD"
    },
    "balance_sheet_Total Liabilities": {
        "tag": "Liabilities",
        "description": "Total obligations of the company arising from past transactions. Used in leverage ratios like Debt-to-Assets and Debt-to-Equity. Unit: USD.",
        "theme": "Leverage",
        "unit": "USD"
    },
    "balance_sheet_Stockholders Equity": {
        "tag": "StockholdersEquity",
        "description": "Residual interest in the company's assets after deducting liabilities. Used in ROE and Debt-to-Equity ratio calculations. Unit: USD.",
        "theme": "Leverage",
        "unit": "USD"
    },

    # -------------------- CASH FLOW --------------------
    "cash_flow_Operating Cash Flow": {
        "tag": "NetCashProvidedByUsedInOperatingActivities",
        "description": "Cash generated or used by core business operations. Indicates ability to generate cash from operations. Unit: USD.",
        "theme": "Cash Flow",
        "unit": "USD"
    },
    "cash_flow_Investing Cash Flow": {
        "tag": "NetCashProvidedByUsedInInvestingActivities",
        "description": "Cash used for investing activities (buying/selling assets, acquisitions). Negative cash flow can indicate growth investment. Unit: USD.",
        "theme": "Cash Flow",
        "unit": "USD"
    },
    "cash_flow_Financing Cash Flow": {
        "tag": "NetCashProvidedByUsedInFinancingActivities",
        "description": "Cash from financing activities (debt, equity issuance, dividends). Shows how a company funds operations and growth. Unit: USD.",
        "theme": "Cash Flow",
        "unit": "USD"
    },

    # -------------------- DERIVED METRICS --------------------
    "Return on Assets (ROA) %": {
        "description": "ROA = Net Income ÷ Total Assets × 100. Measures efficiency of using assets to generate profit. Higher ROA indicates better asset utilization. Unit: %",
        "theme": "Profitability",
        "unit": "%"
    },
    "Return on Equity (ROE) %": {
        "description": "ROE = Net Income ÷ Stockholders Equity × 100. Measures how effectively equity is used to generate profit. Unit: %",
        "theme": "Profitability",
        "unit": "%"
    },
    "Gross Profit Margin %": {
        "description": "Gross Profit ÷ Revenue × 100. Shows profitability after cost of goods sold. Higher margin = more efficient operations. Unit: %",
        "theme": "Profitability",
        "unit": "%"
    },
    "Operating Margin %": {
        "description": "Operating Income ÷ Revenue × 100. Shows efficiency of core business operations excluding taxes and interest. Unit: %",
        "theme": "Profitability",
        "unit": "%"
    },
    "Net Profit Margin %": {
        "description": "Net Income ÷ Revenue × 100. Shows overall profitability relative to revenue. Unit: %",
        "theme": "Profitability",
        "unit": "%"
    },
    "Current Ratio": {
        "description": "Current Assets ÷ Current Liabilities. Measures liquidity; ability to cover short-term obligations. Ideal range: 1.2–2.0. Unit: ratio",
        "theme": "Liquidity",
        "unit": "ratio"
    },
    "Debt to Assets Ratio %": {
        "description": "Total Liabilities ÷ Total Assets × 100. Measures leverage; higher means more debt relative to assets. Unit: %",
        "theme": "Leverage",
        "unit": "%"
    },
    "Debt to Equity Ratio %": {
        "description": "Total Liabilities ÷ Stockholders Equity × 100. Measures financial leverage relative to equity. Unit: %",
        "theme": "Leverage",
        "unit": "%"
    },
    "Operating CF to Current Liabilities": {
        "description": "Operating Cash Flow ÷ Current Liabilities. Shows ability to cover short-term obligations with cash from operations. Unit: ratio",
        "theme": "Liquidity",
        "unit": "ratio"
    },
    "Operating CF to Net Income": {
        "description": "Operating Cash Flow ÷ Net Income. Indicates quality of earnings; >1 means cash exceeds accounting profit. Unit: ratio",
        "theme": "Cash Flow",
        "unit": "ratio"
    },
    "Free Cash Flow": {
        "description": "Free Cash Flow = Operating Cash Flow − Investing Cash Flow. Represents cash available for dividends, debt repayment, or growth. Unit: USD",
        "theme": "Cash Flow",
        "unit": "USD"
    }
}


# -------------------- Utility Functions --------------------
def extract_companies(n=None):
    """
    Fetch company tickers and CIKs from SEC JSON.
    Returns: dict {ticker: CIK}
    """
    user_agent = "Karthik Raja (University Project; karthikraja.ai.project@gmail.com)"
    url = 'https://www.sec.gov/files/company_tickers.json'
    headers = {'User-Agent': user_agent}

    try:
        res = requests.get(url, headers=headers)
        res.raise_for_status()
        data = res.json()
    except Exception as e:
        print(f"Failed to fetch company tickers: {e}")
        return {}

    companies = {}
    values_list = list(data.values())
    if n:
        values_list = values_list[:n]

    for entry in values_list:
        ticker = entry.get("ticker")
        cik = entry.get("cik_str")
        if ticker and cik:
            companies[ticker] = str(cik).zfill(10)
        else:
            print(f"Missing ticker/CIK in entry: {entry}")
    return companies

# -------------------- Safe Division --------------------
def safe_div(num, denom):
    """
    Divide two pandas Series or arrays safely.
    Returns np.nan if denominator is zero or Series is missing.
    """
    if num is None or denom is None:
        # Create Series of NaN if input is missing
        length = len(num) if num is not None else (len(denom) if denom is not None else 1)
        return pd.Series(np.nan, index=range(length))
    return np.where((denom != 0) & (~denom.isna()), num / denom, np.nan)

# -------------------- Main Extraction --------------------
def get_company_metrics_json(cik: str, ticker: str, user_agent: str, years=None, retries=3, sleep_time=2):
    """
    Fetch SEC 10-K financial data and calculate derived metrics.
    Returns: list of dicts (metrics JSON)
    """
    client = EdgarClient(user_agent=user_agent)
    cik = str(cik).zfill(10)

    # Retry logic
    for attempt in range(retries):
        try:
            facts = client.get_company_facts(cik=cik)
            break
        except Exception as e:
            print(f"Attempt {attempt+1} failed for {ticker}: {e}")
            if attempt < retries - 1:
                time.sleep(sleep_time * (attempt + 1))
            else:
                print(f" Skipping {ticker} after {retries} failed attempts.")
                return []

    data = []

    # Extract raw metrics
    for label, tag_info in XBRL_TAGS.items():
        tag = tag_info.get("tag")
        if not tag:
            continue  # Skip derived metrics

        val_list = facts.get("facts", {}).get("us-gaap", {}).get(tag, {}).get("units", {}).get("USD", [])
        latest_by_year = {}

        for v in val_list:
            if v.get("form") == "10-K" and v.get("fp") == "FY" and v.get("val") is not None:
                fy = v.get("fy")
                if years is None or fy in years:
                    if fy not in latest_by_year or v.get("filed", "") > latest_by_year[fy].get("filed", ""):
                        latest_by_year[fy] = v

        for fy, v in latest_by_year.items():
            entry = {
                "company": ticker,
                "ticker": ticker,
                "year": int(fy),
                "metric": label,
                "value": v.get("val"),
                "unit": tag_info.get("unit", "USD"),
                "theme": tag_info.get("theme", ""),
                "description": tag_info.get("description", ""),
                "summary": f"{label} for {ticker} in FY{fy} is {v.get('val')} {tag_info.get('unit','USD')}. {tag_info.get('description','')}",
                "filing_date": v.get("filed", ""),
                "source": "SEC 10-K"
            }
            data.append(entry)

    # Convert to DataFrame
    df = pd.DataFrame(data)
    if df.empty:
        print(f"⚠️ No data found for {ticker}")
        return []

    # Pivot table for derived metrics
    df_pivot = df.pivot_table(index="year", columns="metric", values="value", aggfunc="last").reset_index()
    df_pivot["ticker"] = ticker

    # Ensure all expected columns exist
    expected_cols = [label for label, tag in XBRL_TAGS.items() if tag.get("tag")]  # skip derived metrics
    for col in expected_cols:
        if col not in df_pivot.columns:
            df_pivot[col] = np.nan
            print(f" Column missing for {ticker}: {col} -> filled with NaN")

    # Derived metrics calculations
    df_pivot["Return on Assets (ROA) %"] = safe_div(df_pivot.get("income_stmt_Net Income"), df_pivot.get("balance_sheet_Total Assets")) * 100
    df_pivot["Return on Equity (ROE) %"] = safe_div(df_pivot.get("income_stmt_Net Income"), df_pivot.get("balance_sheet_Stockholders Equity")) * 100
    df_pivot["Gross Profit Margin %"] = safe_div(df_pivot.get("income_stmt_Gross Profit"), df_pivot.get("income_stmt_Revenue")) * 100
    df_pivot["Operating Margin %"] = safe_div(df_pivot.get("income_stmt_Operating Expenses"), df_pivot.get("income_stmt_Revenue")) * 100
    df_pivot["Net Profit Margin %"] = safe_div(df_pivot.get("income_stmt_Net Income"), df_pivot.get("income_stmt_Revenue")) * 100
    df_pivot["Current Ratio"] = safe_div(df_pivot.get("balance_sheet_Current Assets"), df_pivot.get("balance_sheet_Current Liabilities"))
    df_pivot["Debt to Assets Ratio %"] = safe_div(df_pivot.get("balance_sheet_Total Liabilities"), df_pivot.get("balance_sheet_Total Assets")) * 100
    df_pivot["Debt to Equity Ratio %"] = safe_div(df_pivot.get("balance_sheet_Total Liabilities"), df_pivot.get("balance_sheet_Stockholders Equity")) * 100
    df_pivot["Operating CF to Current Liabilities"] = safe_div(df_pivot.get("cash_flow_Operating Cash Flow"), df_pivot.get("balance_sheet_Current Liabilities"))
    df_pivot["Operating CF to Net Income"] = safe_div(df_pivot.get("cash_flow_Operating Cash Flow"), df_pivot.get("income_stmt_Net Income"))
    df_pivot["Free Cash Flow"] = df_pivot.get("cash_flow_Operating Cash Flow") - df_pivot.get("cash_flow_Investing Cash Flow")

    # Append derived metrics to JSON
    derived_metrics = [c for c in df_pivot.columns if c not in df.columns and c not in ["ticker", "year"]]
    json_data = data.copy()

    for _, row in df_pivot.iterrows():
        for metric in derived_metrics:
            val = row.get(metric)
            if pd.notna(val):
                tag_info = XBRL_TAGS.get(metric, {})
                entry = {
                    "company": ticker,
                    "ticker": ticker,
                    "year": int(row["year"]),
                    "metric": metric,
                    "value": round(float(val), 2),
                    "unit": tag_info.get("unit", ""),
                    "theme": tag_info.get("theme", ""),
                    "description": tag_info.get("description", ""),
                    "summary": f"{metric} for {ticker} in FY{int(row['year'])} is {round(float(val),2)}. {tag_info.get('description','')}",
                    "filing_date": "",
                    "source": "SEC 10-K (derived)"
                }
                json_data.append(entry)

    return json_data

def save_to_s3(json_data, bucket_name="sentence-data-ingestion", folder_name="QuantitativeData"):
        
    """
    Uploads metrics JSON data to S3 bucket under the specified subfolder.
    File name includes timestamp for traceability.
    """
    import io
    import json
    import datetime

    try:
        # Create timestamped file name
        timestamp = datetime.datetime.now().strftime("%Y%m%d")
        file_name = f"{folder_name}/metrics_{timestamp}.json"

        # Convert Python object to JSON string
        json_bytes = json.dumps(json_data, indent=4).encode("utf-8")

        # Upload JSON to S3
        s3_client.put_object(
            Bucket=bucket_name,
            Key=file_name,
            Body=json_bytes,
            ContentType="application/json"
        )

        print(f"Successfully uploaded metrics to s3://{bucket_name}/{file_name}")
        return f"s3://{bucket_name}/{file_name}"

    except Exception as e:
        print(f"Failed to upload metrics to S3: {e}")
        return None


# ------------------- Example Usage -------------------
if __name__ == "__main__":
    user_agent = "Karthik Raja (University Project; karthikraja.ai.project@gmail.com)"
    year = date.today().year
    all_json = []

    n = 2  # Number of companies
    companies = extract_companies(n)
    # Optionally, manually override companies
    # companies = {"AAPL": "0000320193"}

    for ticker, cik in companies.items():
        print(f"Fetching {ticker}...")
        company_json = get_company_metrics_json(cik, ticker, user_agent, years=range(1900, year))
        all_json.extend(company_json)
        time.sleep(2)

    with open("metrics.json", "w") as f:
        json.dump(all_json, f, indent=4)

     # SAVING TO S3   
    save_to_s3(all_json)

    print("Saved clean JSON for RAG embedding with filing dates.")
